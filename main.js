/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ToggleTablesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  rowThreshold: 10,
  defaultCollapsed: false,
  showRowCount: true,
  animationSpeed: 200,
  customSummaryText: "Click to expand table",
  enableHybridEditMode: true,
  enableMultiLineSupport: true,
  hybridPreviewOpacity: 0.3,
  tableRowStyling: "alternating"
};
var ToggleTablesPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.loadStyles();
    this.applyTableStyling();
    this.registerMarkdownPostProcessor((element, context) => {
      this.processTables(element);
    });
    if (this.settings.enableHybridEditMode) {
      this.registerEditorExtension(this.createHybridEditExtension());
    }
    this.addCommand({
      id: "toggle-table",
      name: "Toggle Table Collapse",
      editorCallback: (editor, view) => {
        this.toggleTableAtCursor(editor, view);
      }
    });
    this.addCommand({
      id: "wrap-table-in-toggle",
      name: "Wrap Table in Toggle",
      editorCallback: (editor, view) => {
        this.wrapTableInToggle(editor, view);
      }
    });
    this.addCommand({
      id: "toggle-hybrid-edit",
      name: "Toggle Hybrid Edit Mode",
      editorCallback: (editor, view) => {
        this.toggleHybridEditMode(editor, view);
      }
    });
    this.addSettingTab(new ToggleTablesSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  loadStyles() {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = "data:text/css;base64," + btoa(`
			/* Toggle Tables Plugin Styles */
			.toggleable-table-wrapper {
				margin: 1em 0;
			}
			.toggleable-table {
				border: 1px solid var(--background-modifier-border);
				border-radius: 6px;
				background: var(--background-secondary);
				overflow: hidden;
				transition: all 0.2s ease-in-out;
			}
			.toggleable-table:hover {
				border-color: var(--interactive-accent);
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
			}
			.toggleable-table-summary {
				padding: 12px 16px;
				background: var(--background-primary);
				border-bottom: 1px solid var(--background-modifier-border);
				cursor: pointer;
				font-weight: 500;
				color: var(--text-normal);
				user-select: none;
				display: flex;
				align-items: center;
				justify-content: space-between;
				transition: background-color 0.2s ease;
			}
			.toggleable-table-summary:hover {
				background: var(--background-secondary);
			}
			.toggleable-table-summary::before {
				content: "\u25B6";
				margin-right: 8px;
				font-size: 0.8em;
				color: var(--text-muted);
				transition: transform 0.2s ease;
			}
			.toggleable-table[open] .toggleable-table-summary::before {
				transform: rotate(90deg);
			}
			.toggleable-table table {
				margin: 0;
				border-collapse: collapse;
				width: 100%;
			}
			.toggleable-table table th,
			.toggleable-table table td {
				padding: 8px 12px;
				border: 1px solid var(--background-modifier-border);
			}
			.toggleable-table table th {
				background: var(--background-primary-alt);
				font-weight: 600;
				color: var(--text-normal);
			}
			.toggleable-table table td {
				background: var(--background-primary);
				color: var(--text-normal);
			}
			.toggleable-table table tr:nth-child(even) td {
				background: var(--toggleable-table-even-row-bg, var(--background-secondary));
			}
			.toggleable-table table tr:hover td {
				background: var(--background-modifier-hover);
			}
		`);
    document.head.appendChild(link);
  }
  processTables(element) {
    const tables = element.querySelectorAll("table");
    tables.forEach((table) => {
      const effectiveRowCount = this.countEffectiveRows(table);
      if (effectiveRowCount > this.settings.rowThreshold) {
        this.makeTableToggleable(table);
      }
    });
  }
  countEffectiveRows(table) {
    if (!this.settings.enableMultiLineSupport) {
      return table.rows.length;
    }
    let effectiveRows = 0;
    table.querySelectorAll("tr").forEach((row) => {
      const cells = row.querySelectorAll("td, th");
      let maxLinesInRow = 1;
      cells.forEach((cell) => {
        var _a;
        const lineBreaks = (((_a = cell.textContent) == null ? void 0 : _a.match(/\n/g)) || []).length;
        const cellLines = lineBreaks + 1;
        maxLinesInRow = Math.max(maxLinesInRow, cellLines);
      });
      effectiveRows += maxLinesInRow;
    });
    return effectiveRows;
  }
  makeTableToggleable(table) {
    var _a;
    if (table.closest(".toggleable-table-wrapper")) {
      return;
    }
    const wrapper = document.createElement("div");
    wrapper.className = "toggleable-table-wrapper";
    const details = document.createElement("details");
    details.className = "toggleable-table";
    if (this.settings.defaultCollapsed) {
      details.setAttribute("open", "");
    }
    const summary = document.createElement("summary");
    summary.className = "toggleable-table-summary";
    let summaryText = this.settings.customSummaryText;
    if (this.settings.showRowCount) {
      const rowCount = table.rows.length;
      summaryText += ` (${this.countEffectiveRows(table)} rows)`;
    }
    summary.textContent = summaryText;
    (_a = table.parentNode) == null ? void 0 : _a.insertBefore(wrapper, table);
    wrapper.appendChild(details);
    details.appendChild(summary);
    details.appendChild(table);
    this.applyTableStyling();
    summary.addEventListener("click", (e) => {
      e.preventDefault();
      details.toggleAttribute("open");
    });
  }
  createHybridEditExtension() {
    const { EditorView } = require("@codemirror/view");
    const { StateField, StateEffect } = require("@codemirror/state");
    const tablePreviewState = StateField.define({
      create: () => ({ active: false, tableRange: null }),
      update: (value, tr) => {
        const cursor = tr.selection.main.head;
        const tableRange = this.findTableRangeAtPosition(tr.doc, cursor);
        if (tableRange) {
          return { active: true, tableRange };
        } else {
          return { active: false, tableRange: null };
        }
      }
    });
    return [
      tablePreviewState,
      EditorView.updateListener.of((update) => {
        if (update.docChanged || update.selectionSet) {
          this.handleHybridEditUpdate(update);
        }
      })
    ];
  }
  findTableRangeAtPosition(doc, pos) {
    const line = doc.lineAt(pos);
    const lineText = line.text;
    if (lineText.includes("|")) {
      const tableStart = this.findTableStartInDoc(doc, line.number);
      const tableEnd = this.findTableEndInDoc(doc, line.number);
      if (tableStart !== -1 && tableEnd !== -1) {
        return { start: tableStart, end: tableEnd };
      }
    }
    return null;
  }
  findTableStartInDoc(doc, lineNum) {
    let currentLine = lineNum;
    while (currentLine >= 0) {
      const line = doc.line(currentLine + 1);
      if (line.text.trim().startsWith("|") && line.text.trim().endsWith("|")) {
        currentLine--;
      } else {
        break;
      }
    }
    return doc.line(currentLine + 2).from;
  }
  findTableEndInDoc(doc, lineNum) {
    let currentLine = lineNum;
    const totalLines = doc.lines;
    while (currentLine < totalLines) {
      const line = doc.line(currentLine + 1);
      if (line.text.trim().startsWith("|") && line.text.trim().endsWith("|")) {
        currentLine++;
      } else {
        break;
      }
    }
    return doc.line(currentLine).to;
  }
  handleHybridEditUpdate(update) {
    if (!this.settings.enableHybridEditMode) return;
    const cursor = update.state.selection.main.head;
    const tableRange = this.findTableRangeAtPosition(update.state.doc, cursor);
    if (tableRange) {
      this.showTablePreview(tableRange);
    } else {
      this.hideTablePreview();
    }
  }
  showTablePreview(tableRange) {
    var _a;
    const activeView = (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.view;
    if (activeView instanceof import_obsidian.MarkdownView) {
      const editor = activeView.editor;
      const tableText = editor.getRange(tableRange.start, tableRange.end);
      this.createFloatingPreview(tableText, tableRange);
    }
  }
  hideTablePreview() {
    const existingPreview = document.querySelector(".table-preview-overlay");
    if (existingPreview) {
      existingPreview.remove();
    }
  }
  createFloatingPreview(tableText, range) {
    var _a;
    this.hideTablePreview();
    const preview = document.createElement("div");
    preview.className = "table-preview-overlay";
    preview.innerHTML = `
			<div class="table-preview-content">
				<div class="table-preview-header">Table Preview</div>
				<div class="table-preview-body">${this.convertMarkdownToHtml(tableText)}</div>
			</div>
		`;
    const activeView = (_a = this.app.workspace.activeLeaf) == null ? void 0 : _a.view;
    if (activeView instanceof import_obsidian.MarkdownView) {
      const editorElement = activeView.editorEl;
      editorElement.appendChild(preview);
    }
  }
  convertMarkdownToHtml(markdown) {
    const lines = markdown.split("\n");
    let html = "<table>";
    lines.forEach((line, index) => {
      if (line.trim().startsWith("|") && line.trim().endsWith("|")) {
        const cells = line.split("|").slice(1, -1);
        const isHeader = index === 0 || lines[index - 1].includes("---");
        html += `<tr>`;
        cells.forEach((cell) => {
          const tag = isHeader ? "th" : "td";
          html += `<${tag}>${cell.trim()}</${tag}>`;
        });
        html += `</tr>`;
      }
    });
    html += "</table>";
    return html;
  }
  toggleHybridEditMode(editor, view) {
    this.settings.enableHybridEditMode = !this.settings.enableHybridEditMode;
    this.saveSettings();
    if (this.settings.enableHybridEditMode) {
      this.registerEditorExtension(this.createHybridEditExtension());
    } else {
      this.hideTablePreview();
    }
  }
  toggleTableAtCursor(editor, view) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const tableStart = this.findTableStart(editor, cursor.line);
    const tableEnd = this.findTableEnd(editor, cursor.line);
    if (tableStart !== -1 && tableEnd !== -1) {
      const activeLeaf = this.app.workspace.activeLeaf;
      if ((activeLeaf == null ? void 0 : activeLeaf.view) instanceof import_obsidian.MarkdownView) {
        const viewElement = activeLeaf.view.contentEl;
        const tables = viewElement.querySelectorAll("table");
        tables.forEach((table) => {
          const wrapper = table.closest(".toggleable-table-wrapper");
          if (wrapper) {
            const details = wrapper.querySelector("details");
            if (details) {
              details.toggleAttribute("open");
            }
          }
        });
      }
    }
  }
  wrapTableInToggle(editor, view) {
    const cursor = editor.getCursor();
    const tableStart = this.findTableStart(editor, cursor.line);
    const tableEnd = this.findTableEnd(editor, cursor.line);
    if (tableStart !== -1 && tableEnd !== -1) {
      const toggleStart = "<!-- toggle-table -->\n";
      const toggleEnd = "\n<!-- /toggle-table -->";
      editor.replaceRange(toggleStart, { line: tableStart, ch: 0 });
      editor.replaceRange(toggleEnd, { line: tableEnd + 1, ch: 0 });
    }
  }
  findTableStart(editor, line) {
    let currentLine = line;
    while (currentLine >= 0) {
      const lineText = editor.getLine(currentLine);
      if (lineText.trim().startsWith("|") && lineText.trim().endsWith("|")) {
        currentLine--;
      } else {
        break;
      }
    }
    return currentLine + 1;
  }
  findTableEnd(editor, line) {
    let currentLine = line;
    const totalLines = editor.lineCount();
    while (currentLine < totalLines) {
      const lineText = editor.getLine(currentLine);
      if (lineText.trim().startsWith("|") && lineText.trim().endsWith("|")) {
        currentLine++;
      } else {
        break;
      }
    }
    return currentLine - 1;
  }
  applyTableStyling() {
    const root = document.documentElement;
    if (this.settings.tableRowStyling === "single") {
      root.style.setProperty("--toggleable-table-even-row-bg", "var(--background-primary)");
    } else {
      root.style.setProperty("--toggleable-table-even-row-bg", "var(--background-secondary)");
    }
  }
};
var ToggleTablesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Toggle Tables Settings" });
    new import_obsidian.Setting(containerEl).setName("Row Threshold").setDesc("Tables with more than this many rows will be made toggleable").addText((text) => text.setPlaceholder("10").setValue(this.plugin.settings.rowThreshold.toString()).onChange(async (value) => {
      this.plugin.settings.rowThreshold = parseInt(value) || 10;
      await this.plugin.saveSettings();
      this.plugin.applyTableStyling();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Collapsed").setDesc("Whether tables should be collapsed by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.defaultCollapsed).onChange(async (value) => {
      this.plugin.settings.defaultCollapsed = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show Row Count").setDesc("Show the number of rows in the toggle summary").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRowCount).onChange(async (value) => {
      this.plugin.settings.showRowCount = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Animation Speed").setDesc("Speed of the toggle animation in milliseconds").addSlider((slider) => slider.setLimits(0, 500, 50).setValue(this.plugin.settings.animationSpeed).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.animationSpeed = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom Summary Text").setDesc("Text to show in the toggle summary").addText((text) => text.setPlaceholder("Click to expand table").setValue(this.plugin.settings.customSummaryText).onChange(async (value) => {
      this.plugin.settings.customSummaryText = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Multi-line Cell Support").setDesc("Count line breaks within cells when determining table size").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMultiLineSupport).onChange(async (value) => {
      this.plugin.settings.enableMultiLineSupport = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Enable Hybrid Edit Mode").setDesc("Show table preview when cursor is in table area").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableHybridEditMode).onChange(async (value) => {
      this.plugin.settings.enableHybridEditMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Hybrid Preview Opacity").setDesc("Opacity of the floating table preview").addSlider((slider) => slider.setLimits(0.1, 1, 0.1).setValue(this.plugin.settings.hybridPreviewOpacity).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.hybridPreviewOpacity = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Table Row Styling").setDesc("Choose how table rows are styled (alternating or single color)").addDropdown((dropdown) => dropdown.addOption("alternating", "Alternating Colors").addOption("single", "Single Color").setValue(this.plugin.settings.tableRowStyling).onChange(async (value) => {
      this.plugin.settings.tableRowStyling = value;
      await this.plugin.saveSettings();
      this.plugin.applyTableStyling();
    }));
  }
};
